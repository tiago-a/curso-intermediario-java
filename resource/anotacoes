Curso de Java 53: Enumeradores (Enum)

	- Enum's garantem que um atributo de uma classe poderá apenas variar pelos valores declarados no enum.
	

Curso de Java 54: Enumeradores como classe (construtor e métodos)

	- Enum's como classe necessitam de pelo menos um atributo e construtor.
	- Enum's extends classe java.lang.Enum, por isso todos métodos estão disponíveis.
	- Enum's Pode ser usando == para comparação, diferente para comparar objetos, que deve ser utilizado o .equals
	- Enum's não são instanciados com 'new', já é feito implicitamente, na declaração do SEGUNDA(1) já está chamando o 'new'
	- Enum's podem implementas classes
	- Enum's não existe herança, apenas classes
	- Enum's podem ser declarados dentro de outras classes
	

Curso de Java 55: Enum: métodos value e valueOf

	- Enum's são como coleções de constantes
	- O método values() traz todos os valores do Enum como um array.
	- O método valueOf() traz o valor do Enum, passando o tipo de Enum e uma string qualquer, sendo que essa deve se igualar ao Enum.
	

Curso de Java 56: Enum: métodos abstratos

	- É possivel declarar o método abstrato dentro do Enum.
	- Podem ser utilizados para determinar o valor dos Enum declarados, após declarar a assinatura do método abstrato, você deverá implementar esse métodos no próprio Enum para
	determinar o seu valor, pode ser um métodos orindo de outra classe também.
	

Curso de Java 57: Wrappers: classes de tipos primitivos

	- Classe Wrappers empacotam tipos primitivos.
	- Essas classes Wrappers tem métodos como 'parse...'.
		Ex: 'Integer' tem o 'parseInt' que "parseia" o valor para integer de uma string, o mesmo para Double que tem o 'parseDouble' e etc
	- Também possui o valueOf, seu objetivo é transformar um tipo primitivo para o da Classe sendo usado.
		Ex: 'Integer.valueOf(214)' teremos um objeto do tipo Integer com valor '214'


Curso de Java 58: Auto-Boxing e Auto-Unboxing

	- autoBoxing é criar um objeto a partir de um valor primitivo:
		Ex: Integer numero = 14;
	- autoUnboxingo é criar um tipo primitivo a partir de um objeto:
		Ex int numero2 = numero14;
	- autoBoxing em expressões;
		Ex: numero++; ou seja numero = numero + 1;
	- mau uso:
		Ex: Double a, b, c;
			a = 10;
			b = 3;
			c = 4;
			
			Double media = (a+b+c)/3;
			
		Nesse caso será feito 3 auto unboxing, depois o valor será calculado, depois será feito um auto boxing do resultado para a variável 'media'
		
		
Curso de Java 59: Importação estática (static import)

	- 'import static' serve para importar métodos staticos de classes no qual não é necessário utilizar o nome da classe.
		Ex:
			Math.pow(2,3)
			
			com 'import static'
			
			import static java.lang.Math.pow;
			
			pow(2,3)
			
		O código tem o mesmo resultado.
		

Curso de Java 60: Escopo de Variáveis

	- Variáveis são acessíveis apenas no seu escopo.
		Ex:
			for (int i=0; i<10; i++){
				...
				System.out.println(i);
				...
			}
			Variavel i é acessível em todo bloco for, fora desse bloco a variavel i não pode ser referenciavel
		
		
Curso de Java 61: Passagem de parâmetros por valor e por referência

	- Ao passar parametros em uma função copias são criadas, portanto, uma variável do tipo primitivo terá seu valor recriado, ou seja, qualquer mudança no valor da variavel
	passada estará valendo apenas para o escopo da função, já se for passado um objeto, uma copia da referencia será passado, logo, uma mudança em um atributo do objeto terá
	efeito no objeto original.
	
	Ex.:
	
		private void funcaFazAlgo(int valor, ClassMinha cl){
			valor = valor + 10;
			cl.setNome("Novo Nome");
		}
		
		-> O valor fora do método continua com seu valor original
		-> O nome do objeto cl mudará em todo escopo para "Novo Nome"
		
	- Referencia de memória é o equivalente a ponteiros em outras linguagens.
	
	
Curso de Java 62: Varargs

	- Permite N paramentros sem precisar declarar todos parametros.
	- Aceita apenas parametros que sejam classes, no caso de utilizar primitivos, usar o seus respectivos wrappers (Ex: para int usar Integer, double usar Double etc...)
	- O parametros do varags deve ser tratado como um vetor.
	- O parametro varags deverá sempre ser o ultimo parametro declador
		Ex:
			ERRADO
			public static void funcaoAqui(int a, Integer... valor, String s){
				...
			}
			
			CERTO
			public static void funcaoAqui(int a,  String s, Integer... valor){
				...
			}
			

Curso de Java 63: printf

	- utiliza-se o %x onde x é a letra que corresponde ao tipo dados
		Ex: %s -> String, %S -> String em MAIUSCULO, %c -> char, %C -> char em MAIUSCULO
	- utilizar '\n' para pular de linha não é uma boa prática, usar então o System.out.println() para pular uma linha
	- Cheat Sheet:
		%[flags][largura][.precisao]x
		x -> caracter de transformação
		
		%p -> referencia a um objeto
		%n -> pula linha (não usar %N)
		%e -> notação cientifica


Curso de Java 64: Classes aninhadas: internas, locais e anônimas

	- Classes internas tem acesso aos atributos das classes externas
	- Classes locais são classes criadas dentro de métodos, e devem ser instanciada no proprio método
	- Classes anonimas são classes que quando instanciadas podem ter o seu comportamento alterado em tempo de execução
		Ex: Anonima anonima = new Anonima(){
				public void novoComportamento(){
					...
					faz coisas novas
					...
				}
			};
	- Classes anoimas podem implementar interfaces.
	
	- Para acesso a bancos evitar usar JDBC, e sim utilizar Hibernate ou JPA (boas práticas)
	- Classes anonimas são muito utilizadas com Collections.
	
	
Curso de Java 65: Annotations (anotações)

	- São metadados, permitem embutir informações complementares no código fonte, essas informações podem ser consumidas de 3 formas diferentes:
		1 - Informações para o compilador
		2 - Runtime (em tempo de execução)
		3 -	No momento de Compilar ou no momento de Deploy. (O container vai conseguir ler essas anotações e vai conseguir configurar adequadamente)
	- São precedidas de @


Curso de Java 66: Garbage Collector (Coletor de Lixo)

	- GC marca os objetos não utilizado na memória HEAP, em seguida remove os objetos e realoca os objetos ainda utilizado para uma melhor aproveitamento de
	memória.
	- Método finalize() marca objetos[classes executando] para serem coletados pelo GC


Curso de Java 67: Threads + métodos start, run e sleep

	- Thread é a menor unidade de código que pode ser executada. Em um programa pode se ter mais de um thread, ou seja, ao mesmo tempo pode se ter várias threads trabalhando
	juntas.
	- Para utilizar threads uma classe pode extender a classe Thread ou implementar a interface Runnable.


Curso de Java 68: Threads: interface Runnable

	- Não é necessário utilizar o método start().
	- Após implementar a interface Runnable é preciso criar um Thread (com Thread thread = new Thread(aqui vai o objeto da classe que implementou a interface)), em seguida usar
	o método start()
	- É possivel instanciar a thread dentro do construtor da classe que implementa a interface runnable e lá mesmo usar o método .start().
	- Ao extender a classe Thread você não pode extender outras classes, mas ao implementar a interface Runnable ainda se tem a opção de extender outras classes.
	

Curso de Java 69: Criando várias Threads + métodos isAlive e join

	- Classes que implementam a interface Runnable não são Thread e sim representam uma instancia de execução de um Thread. Ainda é preciso instanciar a Thread passando a classe
	que implementou a interface Runnable.
	- isAlive é utilizado para receber um boolean se a thread ainda está viva ou não.
	- o método join é utilizado para que a próxima thread a ser executada so começe após o fim da thread anterior ou só inicie depois do tempo passado como parametro no join


Curso de Java 70: Threads: Definindo prioridadess

	- O método setPriority define a prioridade de cada Thread, essa prioridade pode varias de 0 a 10, quanto maior a prioridade mais cedo será executado essa thread
	- Nem sempre essas prioridades serão respeitadas, depende do OS e das config locais
	- A classe Thread tem constantes como MAX_PRIORITY, NORM_PRIORITY, MIN_PRIORITY.


Curso de Java 71: Threads: métodos e blocos sincronizados (synchronized)

	- Sincronização é o ato de coordenar as atividades de duas ou mais Threads.
	- Motivação: quando duas ou mais Threads tentam acessar o mesmo recurso ao mesmo tempo, com o synchronized é possível garatir que o recurso será acessado por um Thread
	por vez.
	
	
Curso de Java 72: Threads: notify, wait e notifyAll

	- Método wait: bloqueia a execução da Thread e a coloca em espera até que seja notificada que pode voltar a executar
	- Método notify: notifica Threads que estão no modo de espera para que voltem a serem executadas
	- Método notifyAll: notifca todas as Threads que estão em espera
	

Curso de Java 73: Threads: suspend, resume e stop

	- suspend: suspender temporariamente a execução da Thread
	- resume: continua a execução da Thread
	- stop: termina a execução da Thread (substituido pelo método interrupt)
	*esses métodos foram retirados a parti da versão Java 2
	
	synchronized ( ) {
		...
	}
	
	- A palavra chave synchronized seguida de parentese mais a chaves significa que aquele bloco de código deve ser executado de forma sincronizada, dentro dele, as palavras
	chaves notify, wait e notifyAll tem efeito, comportamento parecido com 'synchronized' em um método
	- dentro do ()'s vai o recurso a ser sincronizado, pode se um tipo primitivo ou um objeto
	
	
Curso de Java 74: Threads: deadlocks

	- deadlock: A thread 1 bloqueia o objeto 1 e a thread 2 tenta acessar o objeto 1 mas não consegue por conta da thread 1, que desbloquearia o objeto 1 se pudesse a acessar
	o objeto 2 mas a thread 2 bloqueia o objeto 2.
	
	
Curso de Java 75: String: construtores

	- Uma string inicializada a partir do seu construtor padrão [ new String() ] é o mesmo que inicializar uma string vazia [ "" ]
	- Quando utilizamos o operador "new" para criação de uma String, o Java aloca nova memoria pra a nova variavel, porém se for atribuida de forma simple (ex: String s = "simples";) é checado se 
	existe uma string com esse valor, caso sim, a nova string 's' apenas aponta o valor "simples"
	

Curso de Java 76: String: concatenação

	- Para concatenar Strings é possivel usar apenas o sinal de "+"
	- Strings são imutaveis, quando mudamos o valor de uma String, nos estamos na verdade criando uma nova string
	- Concatenar Strings com "+" ou "+=" é uma prática, deixa o código lento
	

Curso de Java 77: String: extraindo chars (charAt, getChars, getBytes, toCharArray)

	- charAt traz o charactere no indice indicado no método
	
	
Curso de Java 78: String: equalsIgnoreCase, regionMatches, startsWith, endsWith, compareTo

	- equals compara valores da String, o mesmo com equalsIgnoreCase, porém ignora se os caractéres são maisúculos ou minúsculos
	

Curso de Java 79: String: fazendo buscas (indexOf, lastIndexOf, contains)

	- indexOf: procura por um caracter ou string em outra string, caso encontra retorna o indice do caracter, caso não encontre retorna -1
	
	
Curso de Java 80: String: modificando uma String (substring, concat, replace, trim)

	- replace: com o replace é possivel trocar o valor do primeiro caracter que combina com o caracter passado por parametro com outro caracter passado por parametro
	
	
Curso de Java 81: String: modificando letras maiúsculas/minúsculas (toLowerCase, toUpperCase)

	- toLowerCase: transforma todos os caracteres para minuscula
	- toUpperCase: transforma todos os caracteres para maiuscula
	
	
Curso de Java 82: String: juntando e separando String (join, split)

	- join: Junta Strings (utiliza varargs)
	- split: separa Strings
	

Curso de Java 83: concatenação com StringBuilder e StringBuffer

	- StringBuilder: [NOT THREAD SAFE]
	- StringBuffer: utilizada para reverter a ordem da string, deletar caracter [THREAD SAFE]
	
	
Curso de Java 84: String Tokenizer

	- Extrair informações de uma String grande
	
	
Curso de Java 85: Classe Math

	- Classe com suporte a funções matemáticas, senos, cossenos, valor absoluta, raiz quadrada etc...
	- Números aleatórios também.
	- Essa classe é muito simple e pode trazer erros, UTILIZAR outra classes como, BigNumber e BigDecimal.	
	
	
Curso de Java 86: Classe Date (Data)

	- Date date = new Date();	date.getTime() : traz o número de milisegundos de hoje desde 1 de jan de 1970
	
	
Curso de Java 87: Classe Calendar

	- Não é insatanciado com new, e sim com getInstance que retorna um singleton
	
	
Curso de Java 88: Classe GregorianCalendar

	- É uma subclase da classe Calendar (que por sua vez é uma classe abstrata)
	- Contem o metodo isLeapYear para verificar se um ano é bisexto ou não, que na classe Calendar não tem.
	
	
Curso de Java 89: Formatando datas com SimpleDateFormat

	- É necessário passar um forma para formatar a data:
		Ex: dd/MM/yyyy -> 04/05/2018
			dd/MMM/yyyy -> 04/May/2018
			

Curso de Java #90: Locale (Internacionalização)

	-


Curso de Java 91: Formatando datas com DateFormat e Locale

	- 	
	
	
	
	
	
	
	
	
	
	
	
	
	
	
	
	
	
	
	
	
	




























	
	
			
		
		
		
		
		
		
		
		
		
		
		
		
		
		
		
		
		
		
		
		
		
		
		
		
		
		
		
		